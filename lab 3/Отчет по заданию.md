Введение
В данной лабораторной работе была модифицирована программа обработки изображений из лабораторной работы №2 для использования двух графических процессоров (GPU) вместо одного. Основная цель - исследовать возможности параллельной обработки данных на нескольких GPU и оценить эффективность масштабирования.

Исходные данные:

Обработка изображений с различными размерами (тестовое изображение 610×381 пикселей)

Три типа фильтров: размытие, выделение границ, шумоподавление

Два идентичных GPU Tesla V100-PCIE-16GB

Технические характеристики системы
Конфигурация GPU:

GPU 0 & GPU 1: Tesla V100-PCIE-16GB

Объем памяти: 16 ГБ каждый

Вычислительные ядра: 5120 (80 SM × 64 ядра)

Пропускная способность памяти: 898 ГБ/с

Загрузка памяти: GPU0 - 53%, GPU1 - 4%

Архитектурные изменения
1. Параллельная модель выполнения
В отличие от последовательной обработки на одном GPU, новая реализация использует:

cpp
// Запуск обработки на двух GPU параллельно
std::future<std::pair<float, bool>> future0 = std::async(std::launch::async, 
    process_gpu_wrapper, std::ref(input), std::ref(output), filter_type, 0, start1, end1);

std::future<std::pair<float, bool>> future1 = std::async(std::launch::async, 
    process_gpu_wrapper, std::ref(input), std::ref(output), filter_type, 1, start2, end2);
2. Балансировка нагрузки
Изображение делится пополам между GPU:

GPU 0: Верхняя половина (49-50% строк)

GPU 1: Нижняя половина (50-51% строк)

3. Обработка граничных областей
Для корректной работы фильтров реализовано расширение границ:

cpp
// Создаем временный буфер с расширенными границами
int extended_height = height + 2;
std::vector<unsigned char> extended_input(width * extended_height * channels);
Реализация многопроцессорной обработки
Ключевые функции:
process_part_parallel() - обработка части изображения на конкретном GPU

apply_filter_parallel_gpu() - координация параллельной обработки

process_gpu_wrapper() - обертка для асинхронного выполнения

Особенности реализации:
Использование std::async для истинной параллельности

Корректная обработка граничных пикселей

Измерение времени выполнения для каждого GPU

Результаты тестирования
Тест с сгенерированным изображением (с шумом)
Фильтр	Время GPU0	Время GPU1	Общее время	Эффективность
Blur	0.401 ms	0.263 ms	6.17 ms	3.25%
Edge	0.308 ms	0.293 ms	6.514 ms	2.36%
Denoise	0.419 ms	0.326 ms	5.397 ms	3.88%
Тест с загруженным изображением
Фильтр	Время GPU0	Время GPU1	Общее время	Эффективность
Blur	0.392 ms	0.473 ms	5.725 ms	4.13%
Edge	0.335 ms	0.294 ms	6.599 ms	2.54%
Denoise	0.377 ms	0.503 ms	5.439 ms	4.62%
Анализ производительности
1. Временные характеристики
Лучшее время: Edge detection (0.293-0.335 ms на GPU)

Худшее время: Denoise filter (0.377-0.503 ms на GPU)

Соотношение производительности GPU: 0.75x - 1.52x

2. Эффективность параллелизации
Низкая эффективность (2.36%-4.62%) обусловлена:

Накладными расходами на синхронизацию

Неоптимальным разделением данных

Разной загрузкой GPU (53% vs 4%)

Временем копирования данных между CPU и GPU

3. Сравнение с однопроцессорной версией
Лаб. работа №2 (один GPU):

Blur: 0.155-0.218 ms

Edge: 0.086-0.088 ms

Denoise: 0.108-0.109 ms

Лаб. работа №3 (два GPU):

Общее время: 5.397-6.599 ms

Вывод: Многопроцессорная версия показала худшие результаты из-за значительных накладных расходов на организацию параллельной работы.
